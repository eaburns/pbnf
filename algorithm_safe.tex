\documentclass{article}
\usepackage{fullpage}
\usepackage{algorithmic}

\begin{document}
\begin{itemize}
  \item search($init$, $cores$)
  \begin{algorithmic}[1]
  \STATE create a thread for each core, and hash tables for $open$ and $closed$
  \STATE insert $init$ into $open$ and $closed$
  \STATE current $\leftarrow$ NULL
  \STATE start threadsearch() on each thread
  \WHILE {any thread is still running}
    \STATE NOOP
  \ENDWHILE
  \STATE return $current$
  \end{algorithmic}
  
  \item shouldswitch()
  \begin{algorithmic}[1]
  \STATE \COMMENT {$m$ is the minumum number of expansions required to balance out locking overhead}
  \IF {$b$ is empty or  $i < m$}
    \STATE return true
  \ELSIF{best node in free list or interference scope is better than best in $b$}
    \STATE return true
  \ELSE
    \FOR {$j$ in $0$ to size(interference scope)}
      \FOR {each $t$ in wait list of $j$}
        \STATE wake($t$)
      \ENDFOR
      \STATE wait list of $j \leftarrow \{\}$
    \ENDFOR
    \STATE return false
  \ENDIF
  \end{algorithmic}

  \item nextnblock($b$)
  \begin{algorithmic}[1]
  \IF {$b$ is not NULL}
    \IF {the best node in $b$ is better than the best on the free list or in interference scope}
      \STATE return $b$
    \ENDIF
    \STATE release($n$)
    \STATE $s \leftarrow$ nblock from interference scope with the best node on its open list
    \IF {the best node in $s$ is better than the best in free list}
      \STATE add this thread's id to wait list for b
    \ELSE
      \STATE $s \leftarrow$ NULL
    \ENDIF
  \ENDIF
  \IF {sigma == 0 for all nblocks and free list is empty}
    \STATE $done \leftarrow$ true
    \STATE wake all threads
  \ENDIF
  \WHILE {free list is empty or ($s$ != NULL and this thread's id is in the wait set of $s$) and $done =$ false}
    \STATE sleep on condition for $s$
  \ENDWHILE
  \IF {$done =$ true}
    \STATE $n \leftarrow$ NULL
  \ELSE
    \STATE $n \leftarrow$ best on free list
    \STATE increment $sigma$ for $n$ and each nblock in its duplicate detection scope
  \ENDIF
  \STATE return $n$
  \end{algorithmic}

  \item release($b$)
  \begin{algorithmic}[1]
  \FOR {$j$ in $0$ to size(interference scope)}
    \FOR {each $t$ in wait list of $j$}
      \STATE wake($t$)
    \ENDFOR
    \STATE wait list of $j \leftarrow \{\}$
  \ENDFOR
  \end{algorithmic}

  \item threadsearch()
  \begin{algorithmic}[1]
  \WHILE {not $done$}
    \STATE $b \leftarrow$ $open$ of nextnblock($b$)
    \STATE $i \leftarrow 0$
    \WHILE {not shouldswitch($i$)}
      \STATE $i \leftarrow i+1$
      \STATE $node \leftarrow$ head of $b$
      \IF{$node$ is a goal}
        \STATE foundgoal($node$)
      \ELSIF {$node$ is not a duplicate}
        \STATE $children \leftarrow$ expand($node$)
        \STATE remove duplicates from $children$
        \STATE insert $children$ into $open$ and $closed$
      \ENDIF
    \ENDWHILE
  \ENDWHILE
  \end{algorithmic}

  \item foundgoal($new$):
  \begin{algorithmic}[1]
      \IF{g($new$) $<$ g($current$)}
        \STATE $current \leftarrow new$
        \STATE prune all nodes from $b$ with g values higher than g($current$)
      \ENDIF
  \end{algorithmic}
\end{itemize}
\end{document}