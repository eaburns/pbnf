\documentclass[style=simple]{powerdot}
\usepackage{graphics}
\usepackage{algorithmic}

\title{Parallel Heuristic Search}
\author{Ethan Burns \and Seth Lemons}

\begin{document}

\maketitle

\begin{slide}{Goal}
  \emph{To solve problems which fit into RAM using parallel computing
    faster and equally as optimally as the serial counterpart.}
\end{slide}

\begin{slide}{Previous Work (KBFS)}
  K-Best First Search
  \begin{itemize}
  \item Expand k-best nodes at one time
  \item Looks over a wider area of the tree at once
  \item Alleviates dead-end sub-trees
  \end{itemize}
\end{slide}

\begin{slide}{Previous Work (PWS)}
  Parallel Window Search
  \begin{itemize}
  \item Based on IDA*
  \item Separate processors look at different cost bounds
  \item Suboptimal unless you wait for previous cost bounds to complete
  \end{itemize}
\end{slide}

\begin{slide}{Previous Work (DTS)}
  Distributed Tree Search
  \begin{itemize}
  \item Allocate processes to separate sub-trees
  \item When a process with only a single processor is allocated: DFS
  \item Release processors to parent processes for re-allocation
  \end{itemize}
\end{slide}

\begin{slide}{Previous Work (PSDD)}
  Parallel Structured Duplicate Detection
  \begin{itemize}
  \item Decompose the search space into duplicate detection scopes
  \item Allocate disjoint duplicate detection scopes to processors
  \item Breadth-first style search
  \end{itemize}
\end{slide}

\begin{slide}{Our Proposed Approach}
  Use PSDD with a best-first search.  Select buckets based on best
  f-value in the bucket.  Expand nodes from a bucket for a minimum
  amount of time to reduce contention, keep expanding until another
  bucket's best f-value is better than the best f-value in the bucket
  currently being searched.
\end{slide}

\begin{slide}{The Algorithm}
  \onslide*{1} {
    search($init$, $cores$)
    \begin{algorithmic}[1]
      \STATE create a thread for each core, and hash tables for $open$ and $closed$
      \STATE insert $init$ into $open$ and $closed$
      \STATE current $\leftarrow$ NULL
      \STATE start threadsearch() on each thread
      \WHILE {any thread is still running}
      \STATE NOOP
      \ENDWHILE
      \STATE return $current$
    \end{algorithmic}
  }
  \onslide*{2} {
    \begin{tiny}
    threadsearch()
    \begin{algorithmic}[1]
      \WHILE {$open$ is not empty}
      \STATE $b \leftarrow$ bucket in $open$ with minimum f valued node
      \STATE increment $sigma$ for $b$ and each bucket in its duplicate detection scope
      \STATE \COMMENT {possibly prune here to save memory}
      \STATE \COMMENT {$m$ is the minumum number of expansions required to balance out locking overhead}
      \STATE \COMMENT {$n$ is the number of nodes in b for which there are no other cheaper nodes in non-locked buckets}
      \FOR {$i=0$ to min(max($m$, $n$), length($b$)$-1$))}
      \STATE $node \leftarrow$ head of $b$
      \IF{$node$ is a goal}
      \STATE foundgoal($node$)
      \ELSIF {$node$ is not a duplicate}
      \STATE $children \leftarrow$ expand($node$)
      \STATE remove duplicates from $children$
      \STATE insert $children$ into $open$ and $closed$
      \ENDIF
      \ENDFOR
      \STATE \COMMENT {possibly prune here to save memory}
      \STATE decrement $sigma$ for $b$ and each bucket in its duplicate detection scope
      \ENDWHILE
    \end{algorithmic}
    \end{tiny}
  }
  \onslide*{3} {
    foundgoal($new$):
    \begin{algorithmic}[1]
      \IF{g($new$) $<$ g($current$)}
      \STATE $current \leftarrow new$
      \STATE prune all nodes from $b$ with g values higher than g($current$)
      \ENDIF
    \end{algorithmic}
  }
\end{slide}

\begin{slide}{Experiment Methodologies}
  \begin{itemize}
  \item Grid world domain
  \item Possibly use the LAMA planner
  \item Get serial performance for the domain
  \item Compare with parallel performance in the domain
  \item Compare to other parallel algorithms
  \end{itemize}
\end{slide}

\begin{slide}{Questions}
\end{slide}

\end{document}
